## CommonJS

+ Node 应用采用的CommonJS模块化规范，每个文件就是一个模块，有自己的作用域，在一个文件里面定义的变量、函数、类都是私有的，对其他文件不可见。**在服务器端，模块加载是运行时同步加载。在浏览器端，模块需要提前编译打包（不能再浏览器中直接使用CommonJS规范）**

+ 特点：

  + 模块中的代码有自己的作用域，不会污染全局
  + 模块可以被多次加载，但只在第一次运行，运行后会缓存起来，之后直接读缓存结果。想要模块重新运行，必须清除缓存。
  + 模块加载顺序就是其再代码中出现的顺序

+ 基本用法

  + 暴露模块

    ```j
    module.exports = value  或
    exports.xxx = value
    ```

  + 引入模块

    ```js
    const xxx = require('aaa')
    // 如果是第三方模块  aaa 为模块名即可
    // 如果是自定义模块  aaa 为模块文件路径
    ```

+ 本质：

  + CommonJS中`mondule`代表当前模块，是一个对象。他的`exports`属性是对外接口，加载模块加载的是该模块的`module.exports`属性
  + `require`的基本功能是用于加载模块文件：读入并执行一个JavaScript文件，然后返回该模块的`exports`对象
  + CommonJS的就加载机制：输入的是被输出的值的浅拷贝，也就是说，模块内部的变化影响不到输出后的值（原始类型，会被缓存），可以通过清除缓存或者使用函数引用（闭包）

## ES6 模块化（ESM）

+ ES6 模块化的设计思想是尽量的静态化，在编译时就能确定模块的依赖关系，以及输入和输出的变量，是官方的语言层面的模块化设计，可以再浏览器中直接使用。

+ 基本用法：

  + 导入导出

    ```js
    //   通过 export 导出
    export const name= 'zhangsan'
    export let age = 15
    // 通过 import 导入   (通过 as 起别名)
    import {name,age as Age} from './xxx.js'
    
    // 通过 export default 默认导出  (只能有一个默认导出)
    export default function(){}
    // 通过 import 导入
    import myFn from './xxx.js'
    ```

+ 本质：

  + `export`语句输出的接口是与其对应值的动态绑定，通过该接口可以获取到模块内部实时的数据

  + ES6 模块化为官方语言层面的模块化设计，可以在浏览器中直接使用，是未来的趋势

    ```html
    <script type='module' src='xxx.js'></script>
    ```

## ESM 和 CommonJS的区别

+ CommonJS 模块输出的是一个**值的拷贝**，ESM输出的是值的**只读引用**
  + CommonJS 是值的拷贝，将值缓存，缓存之后无法改变，除非清理缓存
  + ESM 是动态只读引用，不会缓存值，可以实时获取模块内部数据变化
+ CommonJS 的require() 是**同步加载**模块，ESM的import是**异步加载**模块
+ CommonJS 是**运行时**加载，ESM是**编译时**加载或者静态加载
+ CommonJS加载**有缓存**，ESM加载**没有缓存**
+ CommonJS 加载的是**整个模块**，ESM 可以单独加其中一些方法（**按需导入**）
+ CommonJS模块中的this指向当前模块（module.exports) ，ESM中指向undefined






## Nodejs 与 CommonJS 规范

- 在`Nodejs`中，任意一个文件就是一个模块，具有独立作用域
- 使用`require`导入其他模块
- 将模块`ID`传入`require`实现目标模块定位
- 模块加载是同步进行的



### 模块化分类和加载流程

#### 分类

- 核心模块：`Node` 源码编译写入到二进制文件中（快）
- 文件模块：代码运行时，动态加载（慢）

#### 加载流程

- 路径分析、文件定位、编译执行

1. 路径分析：依据标识符确定模块位置

   - 路径标识符

   - 非路径标识符

2. 文件定位：确定目标模块中具体的文件以及文件类型

   - 按照 `.js` `.json` `.node` 补足模块名
   - 如果都找不到，回去查找 `package.json` 文件，使用 `JSON.parse()`解析
   - 如果还找不到 `.js` `.json` `.node` ,会将 index.js `index.json` `index.node` 进行解析
   - 如果还是没有，则会抛文件不存在异常

3. 编译执行：采用对应的方式完成文件的编译执行

   1. JS 文件

      - 使用 `fs` 模块同步读入目标文件内容

      - 对内容进行语法包装，生成可执行 `JS` 函数
      - 调用函数时传入 `exports`、`module`、`require` 等属性

   2. JSON 文件

      - 通过 `JSON.parse()`进行解析
      - 将解析结果返回给 `exports` 对象

4. 缓存优化原则：提高模块加载速度

   - 标识符确定模块路径后，回去缓存中查找是否存在想要的模块如果有直接返回，如果没有，则执行完整的加载流程
   - 执行完整的加载流程之后，会使用路径作为索引进行缓存，提高下次加载速度

### module 属性

```js
// 任意`js`文件就是一个模块，可以直接使用 module 属性
id // 返回模块标识符，一般是一个绝对路径
filename // 返回文件模块的绝对路径
loaded // 返回布尔值，表示模块是否完成加载
parent // 返回对象从存放调用当前模块的模块
children // 返回数组，存放当前模块调用的其他模块
exports // 返回当前模块需要暴露的内容
paths // 返回数组，存放不同目录下的node_modules位置
```

### require 属性

```js
// 基本功能是读入并且执行一个模块文件
resolve // 返回模块文件绝对路径
extensions // 根据不同后缀名执行解析操作
main // 返回主模块对象
```